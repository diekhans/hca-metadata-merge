#!/bin/env python3
import argparse

import sys
import os
import re
import glob
from pycbio.sys.objDict import ObjDict
import json


def parse_args():
    desc = "Convert metadata in a set of bundles to a TSV"
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--dump", default=False, action="store_true",
                        help="dump data structure")
    parser.add_argument("--tsv", default="/dev/stdout",
                        help="output TSV, if not specified, write to stdout")
    parser.add_argument("project_dir",
                        help="project directory containing bundles, base name becomes project name")
    return parser.parse_args()

def pr_indent(fh, indent, strs):
    fh.write(ident * "  ")
    fh.write(ident * "  ")
    print(, str, sep='', file=fh)


class Node(object):
    def __init__(self, uuid, entity):
        self.uuid = uuid
        self.entity = entity
        self.inputs = []
        self.outputs = []

    def _dump_fields(self, obj, indent):
        for key in obj.keys():
            pr_indent(fh, ident, key)
            if isinstance(obj[key], dict):
                self._dump_fields(obj, indent)

    def dump_fields(self, fh, title, indent):
        pr_indent


class ProcessNode(Node):
    def __init__(self, uuid, process, protocols):
        super().__init__(uuid, process)
        self.protocols = tuple(protocols)


class ProductNode(Node):
    def __init__(self, uuid, product):
        super().__init__(uuid, product)


class Bundle(object):
    """Graph for one bundle"""
    def __init__(self, uuid, links, entities_by_uuid):
        self.uuid = uuid
        self.inputs = []
        self.outputs = []
        self.by_uuid = {}  # bundle UUIDs
        for link in links.links:
            self._add_process(link, entities_by_uuid)

    def _add_process(self, process, entities_by_uuid):
        process = ProcessNode(process.process, entities_by_uuid[process.process],
                              [entities_by_uuid[proto.protocol_id]
                               for proto in process.protocols])
        assert(process.uuid not in self.by_uuid)
        self.by_uuid[process.uuid] = process
        self._add_products(process.inputs, process, True, entities_by_uuid)
        self._add_products(process.outputs, process, False, entities_by_uuid)

    def _add_products(self, uuids, process, is_input, entities_by_uuid):
        for uuid in uuids:
            self._add_product(uuid, process, is_input, entities_by_uuid)

    def _add_product(self, uuid, process, is_input, entities_by_uuid):
        product = self.by_uuid.get(uuid)
        if product is None:
            product = ProductNode(uuid, entities_by_uuid[uuid])
            self.by_uuid.get[uuid] = product
        if is_input:
            process.inputs.append(product)
            product.outputs.append(process)
        else:
            process.outputs.append(product)
            product.inputs.append(process)


class Project(object):
    """all bundles from a project"""
    def __init__(self, name, bundles):
        self.name = name
        self.bundles = bundles


def load_metadata(md_json, entities_by_uuid):
    with open(md_json) as fh:
        entity = json.load(fh, object_hook=ObjDict)
    entities_by_uuid[entity.provenance.document_id] = entity


def load_bundle(bundle_dir, entities_by_uuid):
    with open(os.path.join(bundle_dir, "links.json")) as fh:
        links = json.load(fh, object_hook=ObjDict)
    for dirent in os.scandir(os.path.join(bundle_dir)):
        md_json = dirent.path
        if re.match(r".*_[0-9]+.json$", md_json):
            load_metadata(md_json, entities_by_uuid)
    return Bundle(os.path.basename(os.path.normpath(bundle_dir)), links, entities_by_uuid)


def load_project(project_dir):
    bundle_dirs = glob.glob(os.path.join(project_dir, "*-*-*-*-*"))
    if len(bundle_dirs) == 0:
        raise Exception("no bundles found in {}".format(project_dir))
    entities_by_uuid = {}
    bundles = [load_bundle(bundle_dir, entities_by_uuid)
               for bundle_dir in bundle_dirs]
    return Project(os.path.basename(os.path.normpath(project_dir)), bundles)


def main():
    opts = parse_args()
    project = load_project(opts.project_dir)
    if opts.dump:
        json.dump(project, sys.stderr, indent=4, sort_keys=True,
                  default=lambda x: x.__dict__)
        print(file=sys.stderr)


main()
