#!/bin/env python3
import argparse

import sys
import os
import re
import glob
import json
from collections import defaultdict

class ObjDict(dict):
    """Dict object where keys are field names"""

    def __getattr__(self, name):
        if name in self:
            return self[name]
        else:
            raise AttributeError("No such attribute: " + name)

    def __setattr__(self, name, value):
        self[name] = value

    def __delattr__(self, name):
        if name in self:
            del self[name]
        else:
            raise AttributeError("No such attribute: " + name)


def parse_args():
    desc = "Convert metadata in a set of bundles to a TSV"
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--dump", default=False, action="store_true",
                        help="dump project data structure as JSON")
    parser.add_argument("project_dir",
                        help="project directory containing bundles, base name becomes project name")
    parser.add_argument("metadataJson",
                        help="output combined meatdata")
    return parser.parse_args()

class Node(object):
    def __init__(self, entity, version):
        self.version = version
        self.entity = entity
        self.inputs = set()
        self.outputs = set()

    @property
    def uuid(self):
        return self.entity.provenance.document_id

class Process(Node):
    def __init__(self, entity, version):
        super().__init__(entity, version)
        self.protocols = set()

class Protocol(Node):
    def __init__(self, entity, version):
        super().__init__(entity, version)

class Product(Node):
    def __init__(self, entity, version):
        super().__init__(entity, version)

class Project(Node):
    """Graph for entire project"""
    def __init__(self, entity, version):
        super().__init__(entity, version)
        self.nodes_by_uuid = {}
        self.processes_by_uuid = {}
        self.protocols_by_uuid = {}
        self.products_by_uuid = {}

class Bundle(object):
    """A bundle as maps of the metadata and related entities in the bundle"""
    def __init__(self, bundle_dir):
        self.bundle_entity = self._load_entity(os.path.join(bundle_dir, "bundle.json"))
        self.links_entity = self._load_entity(os.path.join(bundle_dir, "links.json"))
        self.md_entities_by_uuid = {}
        self.md_entities_by_type = defaultdict(list)
        self.versions_by_uuid = self._build_version_table()
        self._load_metadata(bundle_dir)

    @property
    def uuid(self):
        return self.bundle_entity.bundle.uuid

    @property
    def version(self):
        return self.bundle_entity.bundle.version

    def get_project_entity(self):
        ents = self.md_entities_by_type["project"]
        if len(ents) != 1:
            raise Exception("Expected 1 project metadata entity in bundle {}, got {}".format(self.uuid, len(ents)))
        return ents[0]

    def get_entity(self, uuid):
        return self.md_entities_by_uuid[uuid]

    def get_version(self, entity):
        return self.versions_by_uuid[entity.provenance.document_id]

    def _build_version_table(self):
        vers = {}
        vers[self.uuid] = self.version
        for bfile in self.bundle_entity.bundle.files:
            vers[bfile.uuid] = bfile.version
        return vers

    def _load_entity(self, jsonf):
        with open(jsonf) as fh:
            return json.load(fh, object_hook=ObjDict)

    def _load_md_entity(self, md_jsonf):
        ent = self._load_entity(md_jsonf)
        if ent.provenance.document_id in self.md_entities_by_uuid:
            raise Exception("entity {} already exists in bundle {}"
                            .format(ent.provenance.document_id, self.uuid))
        self.md_entities_by_uuid[ent.provenance.document_id] = ent
        self.md_entities_by_type[ent.schema_type].append(ent)
        return ent

    def _load_metadata(self, bundle_dir):
        for dirent in os.scandir(os.path.join(bundle_dir)):
            md_jsonf = dirent.path
            if re.match("^.+_[0-9]+.json$", os.path.basename(md_jsonf)):
                self._load_md_entity(md_jsonf)

class ProjectBuilder(object):
    """build Project object from all bundles"""
    def __init__(self, bundles):
        self.bundles = bundles
        self.project = None

    def _process_bundle_project(self, bundle):
        prod_ent = bundle.get_project_entity()
        prod_ver = bundle.get_version(prod_ent)
        if self.project is not None:
            if prod_ent.provenance.document_id != self.project.uuid:
                raise Exception("Project has multiple project UUIDs {} and {}; count bundles be mixed from multiple projects?"
                                .format(prod_ent.provenance.document_id, self.project.uuid))
            if prod_ver != self.project.version:
                raise Exception("Project {} has multiple version {} and {}; not yet supported"
                                .format(prod_ver, self.project.version))
        else:
            self.project = Project(prod_ent, prod_ver)
            self.project.nodes_by_uuid[self.project.uuid] = self.project

    def _check_dup_version(self, uuid, ver, node_map):
        node = node_map.get(uuid)
        if ver != node.version:
            raise Exception("{} entity {} exists with multiple version {} and {}; not yet supported"
                            .format(node.entity.__class_.__name__, uuid, ver, node.version))

    def _add_node(self, bundle, uuid, node_map, node_cls):
        "same steps for any kind of node"
        ent = bundle.get_entity(uuid)
        ver = bundle.get_version(ent)
        if uuid in node_map:
            self._check_dup_version(uuid, ver, node_map)
        else:
            node_map[uuid] = node_cls(ent, ver)
            self.project.nodes_by_uuid[uuid] = node_map[uuid]

    def _add_process(self, bundle, uuid):
        self._add_node(bundle, uuid, self.project.processes_by_uuid, Process)

    def _add_protocol(self, bundle, uuid):
        self._add_node(bundle, uuid, self.project.protocols_by_uuid, Protocol)

    def _add_product(self, bundle, uuid):
        self._add_node(bundle, uuid, self.project.products_by_uuid, Product)

    def _add_from_bundle_process(self, bundle, process_links):
        self._add_process(bundle, process_links.process)
        for in_uuid in process_links.inputs:
            self._add_process(bundle, in_uuid)
        for out_uuid in process_links.outputs:
            self._add_product(bundle, out_uuid)
        for prot in process_links.protocols:
            self._add_protocol(bundle, prot.protocol_id)

    def _add_nodes_from_bundle(self, bundle):
        self._process_bundle_project(bundle)
        for process_links in bundle.links_entity.links:
            self._add_from_bundle_process(bundle, process_links)

    def _add_nodes_from_bundles(self):
        for bundle in self.bundles:
            self._add_nodes_from_bundle(bundle)

    def _get_node(self, uuid):
        return self.project.nodes_by_uuid[uuid]

    def _link_input(self, process, in_uuid):
        product = self._get_node(in_uuid)
        product.outputs.add(process)
        process.inputs.add(product)

    def _link_output(self, process, out_uuid):
        product = self._get_node(out_uuid)
        product.inputs.add(process)
        process.outputs.add(product)

    def _link_from_bundle_process(self, bundle, process_links):
        process = self._get_node(process_links.process)
        for in_uuid in process_links.inputs:
            self._link_input(process, in_uuid)
        for out_uuid in process_links.outputs:
            self._link_output(process, out_uuid)
        for prot in process_links.protocols:
            process.protocols.add(self._get_node(prot.protocol_id))

    def _link_from_bundle(self, bundle):
        for process_links in bundle.links_entity.links:
            self._link_from_bundle_process(bundle, process_links)

    def _link_from_bundles(self):
        for bundle in self.bundles:
            self._link_from_bundle(bundle)

    def build(self):
        self._add_nodes_from_bundles()
        self._link_from_bundles()

def load_project_bundles(project_dir):
    bundle_dirs = glob.glob(os.path.join(project_dir, "*-*-*-*-*"))
    if len(bundle_dirs) == 0:
        raise Exception("no bundles found in {}".format(project_dir))
    return [Bundle(bundle_dir) for bundle_dir in bundle_dirs]

def main():
    opts = parse_args()
    builder = ProjectBuilder(load_project_bundles(opts.project_dir))
    project = builder.build()
    if opts.dump:
        json.dump(project, sys.stderr, indent=4, sort_keys=True,
                  default=lambda x: x.__dict__)
        print(file=sys.stderr)


main()
